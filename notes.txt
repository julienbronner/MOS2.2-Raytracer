# Faire la sphere

equation t² + 2*t*<u,C-O> + ||C-O||² - R² = 0

u = (j-W/2, i-H/2,  -W/(2*tan(alpha/2)) ) //pas sur de ça

class Vector{
        double coord[3],
        double sqrNorm(),
        Vector get_normalized
}
vector operator +(const Vector Ra, vector Rb)
double dot(..., ...)
Vector operator *(..., double s)


class Sphere{
    Vector O,
    double R,
}

class Ray{
    Vector C, u //origine et vecteur directeur
}

# Faire de la réflexion

Lumiere  en (-1,20,40)

# Plusieurs spheres

class Scene{
    bool intersect(Ray, P, N, albedo)
    std::vector<Sphere> objects;

}
dans main scene.objects.push_back(S1)

# Correction gamma

On rajoute un puissance 0.45 (qui correspond a 1/gamme = 0.45, gamme = 2.2), a la fin, pour calculer la valeur du rendu
Quand on intégrera un fichier en plus, il faudra les mettre à la puissance gamma car ils sont déjà corrigé gamma,
donc il faut faire l'étape inverse pour compenser notre étape finale

# Ombre porté

Pour connaître l'ombre au sol, on renvoit un rayon depuis le point sur le sol vers la lumière 
pour voir s'il y a une intersection avant la lumière
On rajoute un epsilon au point de départ du rayon de Shadow, 
sinon il y a des problemes de précisions (car on se trouve des fois d'un côté ou de l'autre du volume sur lequel on regarde)

# Surface transparente

n1*sin(theta1) = n2*sin(theta2)
si i incident et t transmis
sin(theta_t) = n1/n2 * sin(theta_i)
donc composante tangentielle t_t = n1/n2* i_t (comp tangentielle de incident)
d'ou t_t = n1/n2* (i - <i,N>*N)     avec N le vecteur normal

composante normale t_N = -cos(theta_t)*N = -sqrt(1-sin²(theta_t))*N
                                         = -sqrt(1- (n1/n2)²*sin²(theta_i))*N
                                         = -sqrt(1- (n1/n2)²*(1-cos²(theta_i) ) )*N
                                         = -sqrt(1- (n1/n2)²*(1- <i,N>² ) )*N
Si truc sous la racine est négatif, on a une réflexion totale
Bien faire attention a ce qu'est n1 et n2