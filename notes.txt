# Rapport 

5-6 pages, images de résultats, timing pour les rendus

# Faire la sphere

equation t² + 2*t*<u,C-O> + ||C-O||² - R² = 0

u = (j-W/2, i-H/2,  -W/(2*tan(alpha/2)) ) //pas sur de ça

class Vector{
        double coord[3],
        double sqrNorm(),
        Vector get_normalized
}
vector operator +(const Vector Ra, vector Rb)
double dot(..., ...)
Vector operator *(..., double s)


class Sphere{
    Vector O,
    double R,
}

class Ray{
    Vector C, u //origine et vecteur directeur
}

# Faire de la réflexion

Lumiere  en (-1,20,40)

# Plusieurs spheres

class Scene{
    bool intersect(Ray, P, N, albedo)
    std::vector<Sphere> objects;

}
dans main scene.objects.push_back(S1)

# Correction gamma

On rajoute un puissance 0.45 (qui correspond a 1/gamme = 0.45, gamme = 2.2), a la fin, pour calculer la valeur du rendu
Quand on intégrera un fichier en plus, il faudra les mettre à la puissance gamma car ils sont déjà corrigé gamma,
donc il faut faire l'étape inverse pour compenser notre étape finale

# Ombre porté

Pour connaître l'ombre au sol, on renvoit un rayon depuis le point sur le sol vers la lumière 
pour voir s'il y a une intersection avant la lumière
On rajoute un epsilon au point de départ du rayon de Shadow, 
sinon il y a des problemes de précisions (car on se trouve des fois d'un côté ou de l'autre du volume sur lequel on regarde)

# Surface transparente

Point d'amélioration : n en paramètre de la sphère

n1*sin(theta1) = n2*sin(theta2)
si i incident et t transmis
sin(theta_t) = n1/n2 * sin(theta_i)
donc composante tangentielle t_t = n1/n2* i_t (comp tangentielle de incident)
d'ou t_t = n1/n2* (i - <i,N>*N)     avec N le vecteur normal

composante normale t_N = -cos(theta_t)*N = -sqrt(1-sin²(theta_t))*N
                                         = -sqrt(1- (n1/n2)²*sin²(theta_i))*N
                                         = -sqrt(1- (n1/n2)²*(1-cos²(theta_i) ) )*N
                                         = -sqrt(1- (n1/n2)²*(1- <i,N>² ) )*N
Si truc sous la racine est négatif, on a une réflexion totale
Bien faire attention a ce qu'est n1 et n2

# Eclairage indirect

## Estimation d'intégrale
Estimation d'intégrale problématique avec méthode habituelle (rectangle, trapeze, etc.)
A la place, faire avec une methode aléatoire (type Monte-Carlo)

Faire calcul avec une gaussienne de l'intégrale de cos^10 sur [-pi/2;pi/2]
Pour générer une gaussienne Box-Muller : u1 et u2 qui suivent une loi uniforme [0,1]
x1 = sqrt(-2*ln(u2))*cos(2*pi*u1)
x2 = sqrt(-2*ln(u2))*sin(2*pi*u1)
et x1, x2 suivent deux lois gaussiennes indépendantes, de moyenne nulle et ecart type 1
Pour avoir un écart type non nul on fait x1 = sigma * sqrt(-2*ln(u2))*cos(2*pi*u1) et x2 = sigma * sqrt(-2*ln(u2))*sin(2*pi*u1)
Pour un ecart type de 0.25 (ou 0.3 c'est même mieux) on a la gaussienne très proche de cos^10

## Calcul 

L(w_o) = E(w_o) + integrale( sur demi-sphere, f(w_i, w_o)* L(w_i)*<N, w_i> dw_i )       # cos(O_i) = <N, w_i> 

f c'est la BRDF
f(w_i, w_o) = rho/pi dans le cas diffu 

Propriété de f :
    f > 0
    f(w_i, w_o) = f(w_o, w_i) --> si on inverse les rayons, on a la même chose
    integrale( f(w_i, w_o) * <N, w_i> dw_i) <=1     pour tout w_o

Dans le calcul de L(w_o), on a f(w_i,w_o) qui est constant, on a L(w_i) qu'on a recursivement
donc on veut p(w_i) proportionnel à <N, w_i>

p(w_i) = <N, w_i>/pi

d'ou l'integrale de la somme dans L(w_o) ~= rho * getColor(w) avec w une direction aléatoire
et direction aleatoire qui est calculé par 
    x = cos(2*pi*r1) * sqrt(1-r2)
    y = sin(2*pi*r1) * sqrt(1-r2)
    z =sqrt(r2)

# Anti aliasing
Images 11
par rapport au screen, rajouter 0.5 pour chaque composante pour centrer (au final pas fait, parce que ps sur que ce soit bon)

# Surface emissive (lumière avec une dimension)
Images 12-13
on passe d'une emission en I/(4*PI) à I/(4*PI*R²) avec R le rayon de la sphere lumineuse

# Modéliser la caméra

L'origine de la caméra n'est pas un point, mais une surface : on prend donc aléatoirement un point de cette surface aléatoirement
comme origine. Normalement la surface c'est une hexagone, mais on peut prendre un cercle pour simplifier
ou même un obturateur gaussien

# Maillage

Généralement on fait un triangle
class Mesh
    std::vector<Vector> vertices
    std::vector<Triplet> faces

Un sommet ("vertices") aura un vector pour être défini en position
On note chaque sommet par un numéro, donc un triangle sera résumé par ses trois sommets (ce sera les "faces")
On fait toujours le même sens de parcours (horaire ou anti-horaire)
On utilise un parser déjà fait pour lire les fichiers .obj

Pour intersecter un rayon et notre ensemble de triangle, on fait comme avec les spheres : on va tester l'intersection
avec tous les triangles, et on prend l'intersection la plus proche
Pour l'intersection : algorithme de Möller Trumbore
On peut définir les points d'un triangle ABC par 
    P = alpha*A + beta*B + gamma*C avec alpha+beta+gamma = 1 et alpha, beta, gamme >=1

## Pour accélerer, on teste d'abord avec la boite englobante

## Bounding box successive

Struct Noeud {
    Noeud* fg, Noeud* fd
    Bbox b
    int debut, fin_exclu
}

int indice_pivot = noeud.debut
for i = noeud.debut .. noeuf.fin
    if centre[triangle[i]]< milieu_boite:
        swap(triangle[i], triangle[indice_pivot])
        indice_pivot++

Condition d'arrêt : indice du pivot qui n'a pas du tout été augmenté, ou indice du pivot à la toute fin 
                    ou seuil d'arrêt s'il n'y que 3 triangles (ou 4 ou 5) dans l'arbre

Cette création d'arbre se fait après le chargement de l'image et une fois les modifications d'echelle ou d'emplacement faites

Ensuite on fait un parcours en profondeur de l'arbre (pour faciliter de potentielles améliorations)

Dans la routine d'intersection du maillage : 

List<Noeud*> l;
l.push_back(racine)
if(!intersect(ray, racine)) # il n'y a même d'intersection avec la boite de base
    return, # on retourne rien
while (!l.empty())
    Noeud* courant = l.front
    l.pop_front()
    if (intersect(ray, courant->fg)) # s'il y a un fils gauche
        l.push_front(c->fg);
    pareil droite
    else : # pas de fils gauche
        comme avant : 
        pour tout i entre [c.debut, c.fin]
            intersect(rayon, triangle[i])